// <auto-generated/>
#pragma warning disable CS0618
using Microsoft.Kiota.Abstractions.Extensions;
using Microsoft.Kiota.Abstractions.Serialization;
using System.Collections.Generic;
using System.IO;
using System;
namespace DoclingServe.Models
{
    /// <summary>
    /// Conversion options.
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
    public partial class ConvertDocumentsRequestOptions : IAdditionalDataHolder, IParsable
    {
        /// <summary>Abort on error if enabled. Boolean. Optional, defaults to false.</summary>
        public bool? AbortOnError { get; set; }
        /// <summary>Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.</summary>
        public IDictionary<string, object> AdditionalData { get; set; }
        /// <summary>If enabled, perform OCR code enrichment. Boolean. Optional, defaults to false.</summary>
        public bool? DoCodeEnrichment { get; set; }
        /// <summary>The timeout for processing each document, in seconds.</summary>
        public double? DocumentTimeout { get; set; }
        /// <summary>If enabled, perform formula OCR, return LaTeX code. Boolean. Optional, defaults to false.</summary>
        public bool? DoFormulaEnrichment { get; set; }
        /// <summary>If enabled, the bitmap content will be processed using OCR. Boolean. Optional, defaults to true</summary>
        public bool? DoOcr { get; set; }
        /// <summary>If enabled, classify pictures in documents. Boolean. Optional, defaults to false.</summary>
        public bool? DoPictureClassification { get; set; }
        /// <summary>If enabled, describe pictures in documents. Boolean. Optional, defaults to false.</summary>
        public bool? DoPictureDescription { get; set; }
        /// <summary>If enabled, the table structure will be extracted. Boolean. Optional, defaults to true.</summary>
        public bool? DoTableStructure { get; set; }
        /// <summary>If enabled, replace existing text with OCR-generated text over content. Boolean. Optional, defaults to false.</summary>
        public bool? ForceOcr { get; set; }
        /// <summary>Input format(s) to convert from. String or list of strings. Allowed values: docx, pptx, html, image, pdf, asciidoc, md, csv, xlsx, xml_uspto, xml_jats, mets_gbs, json_docling, audio, vtt. Optional, defaults to all formats.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public List<global::DoclingServe.Models.InputFormat?>? FromFormats { get; set; }
#nullable restore
#else
        public List<global::DoclingServe.Models.InputFormat?> FromFormats { get; set; }
#endif
        /// <summary>Image export mode for the document (in case of JSON, Markdown or HTML). Allowed values: placeholder, embedded, referenced. Optional, defaults to Embedded.</summary>
        public global::DoclingServe.Models.ImageRefMode? ImageExportMode { get; set; }
        /// <summary>Scale factor for images. Float. Optional, defaults to 2.0.</summary>
        public double? ImagesScale { get; set; }
        /// <summary>If enabled, images will be extracted from the document. Boolean. Optional, defaults to true.</summary>
        public bool? IncludeImages { get; set; }
        /// <summary>Add this placeholder between pages in the markdown output.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? MdPageBreakPlaceholder { get; set; }
#nullable restore
#else
        public string MdPageBreakPlaceholder { get; set; }
#endif
        /// <summary>The OCR engine to use. String. Allowed values: auto, easyocr, ocrmac, rapidocr, tesserocr, tesseract. Optional, defaults to easyocr.</summary>
        public global::DoclingServe.Models.Ocr_engines_enum? OcrEngine { get; set; }
        /// <summary>List of languages used by the OCR engine. Note that each OCR engine has different values for the language names. String or list of strings. Optional, defaults to empty.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::DoclingServe.Models.ConvertDocumentsRequestOptions.ConvertDocumentsRequestOptions_ocr_lang? OcrLang { get; set; }
#nullable restore
#else
        public global::DoclingServe.Models.ConvertDocumentsRequestOptions.ConvertDocumentsRequestOptions_ocr_lang OcrLang { get; set; }
#endif
        /// <summary>Only convert a range of pages. The page number starts at 1.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public UntypedNode? PageRange { get; set; }
#nullable restore
#else
        public UntypedNode PageRange { get; set; }
#endif
        /// <summary>The PDF backend to use. String. Allowed values: pypdfium2, dlparse_v1, dlparse_v2, dlparse_v4. Optional, defaults to dlparse_v4.</summary>
        public global::DoclingServe.Models.PdfBackend? PdfBackend { get; set; }
        /// <summary>API details for using a vision-language model in the picture description. This parameter is mutually exclusive with picture_description_local.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::DoclingServe.Models.PictureDescriptionApi? PictureDescriptionApi { get; set; }
#nullable restore
#else
        public global::DoclingServe.Models.PictureDescriptionApi PictureDescriptionApi { get; set; }
#endif
        /// <summary>Minimum percentage of the area for a picture to be processed with the models.</summary>
        public double? PictureDescriptionAreaThreshold { get; set; }
        /// <summary>Options for running a local vision-language model in the picture description. The parameters refer to a model hosted on Hugging Face. This parameter is mutually exclusive with picture_description_api.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::DoclingServe.Models.PictureDescriptionLocal? PictureDescriptionLocal { get; set; }
#nullable restore
#else
        public global::DoclingServe.Models.PictureDescriptionLocal PictureDescriptionLocal { get; set; }
#endif
        /// <summary>Choose the pipeline to process PDF or image files.</summary>
        public global::DoclingServe.Models.ProcessingPipeline? Pipeline { get; set; }
        /// <summary>If true, matches table cells predictions back to PDF cells. Can break table output if PDF cells are merged across table columns. If false, let table structure model define the text cells, ignore PDF cells.</summary>
        public bool? TableCellMatching { get; set; }
        /// <summary>Mode to use for table structure, String. Allowed values: fast, accurate. Optional, defaults to accurate.</summary>
        public global::DoclingServe.Models.TableFormerMode? TableMode { get; set; }
        /// <summary>Output format(s) to convert to. String or list of strings. Allowed values: md, json, html, html_split_page, text, doctags. Optional, defaults to Markdown.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public List<global::DoclingServe.Models.OutputFormat?>? ToFormats { get; set; }
#nullable restore
#else
        public List<global::DoclingServe.Models.OutputFormat?> ToFormats { get; set; }
#endif
        /// <summary>Preset of local and API models for the vlm pipeline. This parameter is mutually exclusive with vlm_pipeline_model_local and vlm_pipeline_model_api. Use the other options for more parameters.</summary>
        public global::DoclingServe.Models.VlmModelType? VlmPipelineModel { get; set; }
        /// <summary>API details for using a vision-language model for the vlm pipeline. This parameter is mutually exclusive with vlm_pipeline_model_local and vlm_pipeline_model.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::DoclingServe.Models.VlmModelApi? VlmPipelineModelApi { get; set; }
#nullable restore
#else
        public global::DoclingServe.Models.VlmModelApi VlmPipelineModelApi { get; set; }
#endif
        /// <summary>Options for running a local vision-language model for the vlm pipeline. The parameters refer to a model hosted on Hugging Face. This parameter is mutually exclusive with vlm_pipeline_model_api and vlm_pipeline_model.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::DoclingServe.Models.VlmModelLocal? VlmPipelineModelLocal { get; set; }
#nullable restore
#else
        public global::DoclingServe.Models.VlmModelLocal VlmPipelineModelLocal { get; set; }
#endif
        /// <summary>
        /// Instantiates a new <see cref="global::DoclingServe.Models.ConvertDocumentsRequestOptions"/> and sets the default values.
        /// </summary>
        public ConvertDocumentsRequestOptions()
        {
            AdditionalData = new Dictionary<string, object>();
            ImageExportMode = global::DoclingServe.Models.ImageRefMode.Embedded;
            OcrEngine = global::DoclingServe.Models.Ocr_engines_enum.Easyocr;
            PdfBackend = global::DoclingServe.Models.PdfBackend.Dlparse_v4;
            Pipeline = global::DoclingServe.Models.ProcessingPipeline.Standard;
            TableMode = global::DoclingServe.Models.TableFormerMode.Accurate;
        }
        /// <summary>
        /// Creates a new instance of the appropriate class based on discriminator value
        /// </summary>
        /// <returns>A <see cref="global::DoclingServe.Models.ConvertDocumentsRequestOptions"/></returns>
        /// <param name="parseNode">The parse node to use to read the discriminator value and create the object</param>
        public static global::DoclingServe.Models.ConvertDocumentsRequestOptions CreateFromDiscriminatorValue(IParseNode parseNode)
        {
            if(ReferenceEquals(parseNode, null)) throw new ArgumentNullException(nameof(parseNode));
            return new global::DoclingServe.Models.ConvertDocumentsRequestOptions();
        }
        /// <summary>
        /// The deserialization information for the current model
        /// </summary>
        /// <returns>A IDictionary&lt;string, Action&lt;IParseNode&gt;&gt;</returns>
        public virtual IDictionary<string, Action<IParseNode>> GetFieldDeserializers()
        {
            return new Dictionary<string, Action<IParseNode>>
            {
                { "abort_on_error", n => { AbortOnError = n.GetBoolValue(); } },
                { "do_code_enrichment", n => { DoCodeEnrichment = n.GetBoolValue(); } },
                { "do_formula_enrichment", n => { DoFormulaEnrichment = n.GetBoolValue(); } },
                { "do_ocr", n => { DoOcr = n.GetBoolValue(); } },
                { "do_picture_classification", n => { DoPictureClassification = n.GetBoolValue(); } },
                { "do_picture_description", n => { DoPictureDescription = n.GetBoolValue(); } },
                { "do_table_structure", n => { DoTableStructure = n.GetBoolValue(); } },
                { "document_timeout", n => { DocumentTimeout = n.GetDoubleValue(); } },
                { "force_ocr", n => { ForceOcr = n.GetBoolValue(); } },
                { "from_formats", n => { FromFormats = n.GetCollectionOfEnumValues<global::DoclingServe.Models.InputFormat>()?.AsList(); } },
                { "image_export_mode", n => { ImageExportMode = n.GetEnumValue<global::DoclingServe.Models.ImageRefMode>(); } },
                { "images_scale", n => { ImagesScale = n.GetDoubleValue(); } },
                { "include_images", n => { IncludeImages = n.GetBoolValue(); } },
                { "md_page_break_placeholder", n => { MdPageBreakPlaceholder = n.GetStringValue(); } },
                { "ocr_engine", n => { OcrEngine = n.GetEnumValue<global::DoclingServe.Models.Ocr_engines_enum>(); } },
                { "ocr_lang", n => { OcrLang = n.GetObjectValue<global::DoclingServe.Models.ConvertDocumentsRequestOptions.ConvertDocumentsRequestOptions_ocr_lang>(global::DoclingServe.Models.ConvertDocumentsRequestOptions.ConvertDocumentsRequestOptions_ocr_lang.CreateFromDiscriminatorValue); } },
                { "page_range", n => { PageRange = n.GetObjectValue<UntypedNode>(UntypedNode.CreateFromDiscriminatorValue); } },
                { "pdf_backend", n => { PdfBackend = n.GetEnumValue<global::DoclingServe.Models.PdfBackend>(); } },
                { "picture_description_api", n => { PictureDescriptionApi = n.GetObjectValue<global::DoclingServe.Models.PictureDescriptionApi>(global::DoclingServe.Models.PictureDescriptionApi.CreateFromDiscriminatorValue); } },
                { "picture_description_area_threshold", n => { PictureDescriptionAreaThreshold = n.GetDoubleValue(); } },
                { "picture_description_local", n => { PictureDescriptionLocal = n.GetObjectValue<global::DoclingServe.Models.PictureDescriptionLocal>(global::DoclingServe.Models.PictureDescriptionLocal.CreateFromDiscriminatorValue); } },
                { "pipeline", n => { Pipeline = n.GetEnumValue<global::DoclingServe.Models.ProcessingPipeline>(); } },
                { "table_cell_matching", n => { TableCellMatching = n.GetBoolValue(); } },
                { "table_mode", n => { TableMode = n.GetEnumValue<global::DoclingServe.Models.TableFormerMode>(); } },
                { "to_formats", n => { ToFormats = n.GetCollectionOfEnumValues<global::DoclingServe.Models.OutputFormat>()?.AsList(); } },
                { "vlm_pipeline_model", n => { VlmPipelineModel = n.GetEnumValue<global::DoclingServe.Models.VlmModelType>(); } },
                { "vlm_pipeline_model_api", n => { VlmPipelineModelApi = n.GetObjectValue<global::DoclingServe.Models.VlmModelApi>(global::DoclingServe.Models.VlmModelApi.CreateFromDiscriminatorValue); } },
                { "vlm_pipeline_model_local", n => { VlmPipelineModelLocal = n.GetObjectValue<global::DoclingServe.Models.VlmModelLocal>(global::DoclingServe.Models.VlmModelLocal.CreateFromDiscriminatorValue); } },
            };
        }
        /// <summary>
        /// Serializes information the current object
        /// </summary>
        /// <param name="writer">Serialization writer to use to serialize this model</param>
        public virtual void Serialize(ISerializationWriter writer)
        {
            if(ReferenceEquals(writer, null)) throw new ArgumentNullException(nameof(writer));
            writer.WriteBoolValue("abort_on_error", AbortOnError);
            writer.WriteBoolValue("do_code_enrichment", DoCodeEnrichment);
            writer.WriteDoubleValue("document_timeout", DocumentTimeout);
            writer.WriteBoolValue("do_formula_enrichment", DoFormulaEnrichment);
            writer.WriteBoolValue("do_ocr", DoOcr);
            writer.WriteBoolValue("do_picture_classification", DoPictureClassification);
            writer.WriteBoolValue("do_picture_description", DoPictureDescription);
            writer.WriteBoolValue("do_table_structure", DoTableStructure);
            writer.WriteBoolValue("force_ocr", ForceOcr);
            writer.WriteCollectionOfEnumValues<global::DoclingServe.Models.InputFormat>("from_formats", FromFormats);
            writer.WriteEnumValue<global::DoclingServe.Models.ImageRefMode>("image_export_mode", ImageExportMode);
            writer.WriteDoubleValue("images_scale", ImagesScale);
            writer.WriteBoolValue("include_images", IncludeImages);
            writer.WriteStringValue("md_page_break_placeholder", MdPageBreakPlaceholder);
            writer.WriteEnumValue<global::DoclingServe.Models.Ocr_engines_enum>("ocr_engine", OcrEngine);
            writer.WriteObjectValue<global::DoclingServe.Models.ConvertDocumentsRequestOptions.ConvertDocumentsRequestOptions_ocr_lang>("ocr_lang", OcrLang);
            writer.WriteObjectValue<UntypedNode>("page_range", PageRange);
            writer.WriteEnumValue<global::DoclingServe.Models.PdfBackend>("pdf_backend", PdfBackend);
            writer.WriteObjectValue<global::DoclingServe.Models.PictureDescriptionApi>("picture_description_api", PictureDescriptionApi);
            writer.WriteDoubleValue("picture_description_area_threshold", PictureDescriptionAreaThreshold);
            writer.WriteObjectValue<global::DoclingServe.Models.PictureDescriptionLocal>("picture_description_local", PictureDescriptionLocal);
            writer.WriteEnumValue<global::DoclingServe.Models.ProcessingPipeline>("pipeline", Pipeline);
            writer.WriteBoolValue("table_cell_matching", TableCellMatching);
            writer.WriteEnumValue<global::DoclingServe.Models.TableFormerMode>("table_mode", TableMode);
            writer.WriteCollectionOfEnumValues<global::DoclingServe.Models.OutputFormat>("to_formats", ToFormats);
            writer.WriteEnumValue<global::DoclingServe.Models.VlmModelType>("vlm_pipeline_model", VlmPipelineModel);
            writer.WriteObjectValue<global::DoclingServe.Models.VlmModelApi>("vlm_pipeline_model_api", VlmPipelineModelApi);
            writer.WriteObjectValue<global::DoclingServe.Models.VlmModelLocal>("vlm_pipeline_model_local", VlmPipelineModelLocal);
            writer.WriteAdditionalData(AdditionalData);
        }
        /// <summary>
        /// Composed type wrapper for classes <see cref="global::DoclingServe.Models.ConvertDocumentsRequestOptions_ocr_langMember1"/>, List&lt;string&gt;
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
        public partial class ConvertDocumentsRequestOptions_ocr_lang : IComposedTypeWrapper, IParsable
        {
            /// <summary>Composed type representation for type <see cref="global::DoclingServe.Models.ConvertDocumentsRequestOptions_ocr_langMember1"/></summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
            public global::DoclingServe.Models.ConvertDocumentsRequestOptions_ocr_langMember1? ConvertDocumentsRequestOptionsOcrLangMember1 { get; set; }
#nullable restore
#else
            public global::DoclingServe.Models.ConvertDocumentsRequestOptions_ocr_langMember1 ConvertDocumentsRequestOptionsOcrLangMember1 { get; set; }
#endif
            /// <summary>Composed type representation for type List&lt;string&gt;</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
            public List<string>? String { get; set; }
#nullable restore
#else
            public List<string> String { get; set; }
#endif
            /// <summary>
            /// Creates a new instance of the appropriate class based on discriminator value
            /// </summary>
            /// <returns>A <see cref="global::DoclingServe.Models.ConvertDocumentsRequestOptions.ConvertDocumentsRequestOptions_ocr_lang"/></returns>
            /// <param name="parseNode">The parse node to use to read the discriminator value and create the object</param>
            public static global::DoclingServe.Models.ConvertDocumentsRequestOptions.ConvertDocumentsRequestOptions_ocr_lang CreateFromDiscriminatorValue(IParseNode parseNode)
            {
                if(ReferenceEquals(parseNode, null)) throw new ArgumentNullException(nameof(parseNode));
                var result = new global::DoclingServe.Models.ConvertDocumentsRequestOptions.ConvertDocumentsRequestOptions_ocr_lang();
                if(parseNode.GetCollectionOfPrimitiveValues<string>()?.AsList() is List<string> stringValue)
                {
                    result.String = stringValue;
                }
                else {
                    result.ConvertDocumentsRequestOptionsOcrLangMember1 = new global::DoclingServe.Models.ConvertDocumentsRequestOptions_ocr_langMember1();
                }
                return result;
            }
            /// <summary>
            /// The deserialization information for the current model
            /// </summary>
            /// <returns>A IDictionary&lt;string, Action&lt;IParseNode&gt;&gt;</returns>
            public virtual IDictionary<string, Action<IParseNode>> GetFieldDeserializers()
            {
                if(ConvertDocumentsRequestOptionsOcrLangMember1 != null)
                {
                    return ParseNodeHelper.MergeDeserializersForIntersectionWrapper(ConvertDocumentsRequestOptionsOcrLangMember1);
                }
                return new Dictionary<string, Action<IParseNode>>();
            }
            /// <summary>
            /// Serializes information the current object
            /// </summary>
            /// <param name="writer">Serialization writer to use to serialize this model</param>
            public virtual void Serialize(ISerializationWriter writer)
            {
                if(ReferenceEquals(writer, null)) throw new ArgumentNullException(nameof(writer));
                if(String != null)
                {
                    writer.WriteCollectionOfPrimitiveValues<string>(null, String);
                }
                else {
                    writer.WriteObjectValue<global::DoclingServe.Models.ConvertDocumentsRequestOptions_ocr_langMember1>(null, ConvertDocumentsRequestOptionsOcrLangMember1);
                }
            }
        }
    }
}
#pragma warning restore CS0618
